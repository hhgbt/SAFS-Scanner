# Exploit Engine 模块功能文档

## 模块概述

`core/exploit_engine.py` 是 V-APF 框架的自动化漏洞利用引擎，负责集成和调用多种安全扫描及漏洞利用工具，包括 sqlmap、BeEF XSS、XSStrike、commix 和 Metasploit Framework。该模块提供异步接口，支持高效的漏洞验证和利用。

**核心职责：**
- SQL 注入漏洞检测与利用（sqlmap）
- XSS 漏洞检测与利用（BeEF、XSStrike）
- 命令注入漏洞检测（commix）
- Metasploit 集成执行（msfconsole）
- 结构化输出与证据提取

---

## 辅助函数

### `_parse_sqlmap_output(text: str) -> Dict[str, Any]`

**功能：** 从 sqlmap 的文本输出中提取关键证据。

**参数：**
- `text` (str): sqlmap 命令的输出文本

**返回值：**
- `Dict[str, Any]`: 包含以下可能的键值：
  - `banner` (str): 数据库服务器标识
  - `current_user` (str): 当前数据库用户
  - `current_db` (str): 当前数据库名称

**实现细节：**
- 使用多种正则表达式模式以兼容不同版本/语言的 sqlmap 输出
- 对于每个证据类型，尝试多个可能的输出格式
- 大小写不敏感匹配

**示例：**
```python
output = "banner: MySQL 5.7.0"
evidence = _parse_sqlmap_output(output)
# 结果: {"banner": "MySQL 5.7.0"}
```

---

### `_find_first_key(obj: Any, keys: List[str]) -> Optional[Any]`

**功能：** 在嵌套的 JSON 对象中递归搜索指定的键列表，返回第一个找到且非空的值。

**参数：**
- `obj` (Any): 任意 Python 对象（dict、list 或其他）
- `keys` (List[str]): 要搜索的键名列表

**返回值：**
- `Optional[Any]`: 找到的第一个非空值，或 `None`

**实现细节：**
- 递归遍历嵌套字典和列表结构
- 优先匹配前面的键（按 keys 列表顺序）
- 适合处理不规范的 JSON 结构

**示例：**
```python
data = {"info": {"user": "admin", "database": "test"}}
user = _find_first_key(data, ["user", "currentUser", "username"])
# 结果: "admin"
```

---

### `_parse_sqlmap_json(obj: Any) -> Tuple[Dict[str, Any], Optional[str]]`

**功能：** 从 sqlmap 的结构化 JSON 输出中提取证据和使用的 payload。

**参数：**
- `obj` (Any): 解析后的 JSON 对象（通常来自 sqlmap --json 输出）

**返回值：**
- `Tuple[Dict[str, Any], Optional[str]]`: 
  - 第一个元素：证据字典，包含：
    - `banner` (str): 数据库标识
    - `current_user` (str): 当前用户
    - `current_db` (str): 当前数据库
    - `json` (dict): 原始 JSON 片段（用于审计）
  - 第二个元素：使用的 payload 字符串

**实现细节：**
- 支持多种字段名称变体（驼峰命名、下划线命名等）
- 使用 `_find_first_key` 递归查找嵌套字段
- 返回原始 JSON 片段便于后续审计

---

## 主要函数

### `async run_sqlmap(url: str, param: str, sqlmap_path: str = "sqlmap", timeout: int = 600, extra_args: Optional[str] = None) -> Dict[str, Any]`

**功能：** 运行 sqlmap 工具进行 SQL 注入检测和利用。

**参数：**
- `url` (str): 目标 URL
- `param` (str): 要测试的参数名，支持：
  - 具体参数名：如 `"cat"`
  - `"ALL"`: 让 sqlmap 自动检测所有参数
  - 空字符串：与 `"ALL"` 等效
- `sqlmap_path` (str, 可选): sqlmap 可执行文件路径，默认 `"sqlmap"`
- `timeout` (int, 可选): 执行超时时间（秒），默认 600
- `extra_args` (Optional[str], 可选): 额外的 sqlmap 命令行参数

**返回值：**
```python
{
    "type": "sqlmap",
    "success": bool,              # 是否检测到 SQL 注入
    "evidence": {
        "banner": str,             # 数据库标识
        "current_user": str,       # 当前用户
        "current_db": str,         # 当前数据库
        "json": dict,              # 原始 JSON（如果可用）
    },
    "payload": Optional[str],      # 使用的 payload
    "raw_output": str,             # 命令输出（前 4000-6000 字符）
    "cmd": str,                    # 实际执行的命令
}
```

**工作流程：**
1. 首先尝试使用 `--json` 参数（结构化输出）
2. 如果 sqlmap 版本不支持 `--json`，自动回退到文本解析
3. 优先解析 JSON 文件，失败则使用正则表达式解析文本
4. 若仍无证据，从日志文件尾部提取信息
5. 超时自动杀死进程并返回失败结果

**执行参数：**
- `--batch`: 非交互模式
- `--banner`: 获取数据库标识
- `--current-user`: 获取当前用户
- `--current-db`: 获取当前数据库
- `--level=3`: 检测级别
- `--risk=2`: 风险级别
- `--flush-session`: 清除之前的会话

**示例：**
```python
result = await run_sqlmap(
    url="http://testphp.vulnweb.com/listproducts.php?cat=1",
    param="cat",
    extra_args="--technique=BEUSTQ"
)
if result["success"]:
    print(f"数据库: {result['evidence']['current_db']}")
    print(f"用户: {result['evidence']['current_user']}")
```

---

### `async run_beef_xss(beef_path: str = "beef-xss", timeout: int = 20) -> Dict[str, Any]`

**功能：** 尝试启动 BeEF (Browser Exploitation Framework) 验证其可用性。

**参数：**
- `beef_path` (str, 可选): BeEF 可执行文件路径，默认 `"beef-xss"`
- `timeout` (int, 可选): 启动超时时间（秒），默认 20

**返回值：**
```python
{
    "type": "beef-xss",
    "success": bool,               # BeEF 是否可用
    "evidence": {},                # 当前不提取证据
    "raw_output": str,             # 启动输出
    "cmd": str,                    # 实际执行的命令或路径
}
```

**工作流程：**
1. 检查 BeEF 可执行文件是否存在
2. 在非 Linux/Unix 系统上或无 root 权限时跳过执行（避免权限错误）
3. 启动进程并等待指定时间后杀死
4. 根据输出判断 BeEF 是否成功启动

**限制说明：**
- 仅验证 BeEF 的可用性，不进行实际的 payload 投递
- 完整的 XSS 钓鱼和 browser hooking 需要单独配置和受害者导航
- 需要 root 权限（在 Linux/Unix 上）

**示例：**
```python
result = await run_beef_xss()
if result["success"]:
    print("BeEF 框架可用")
```

---

### `async run_xsstrike(url: str, xsstrike_path: str = "xsstrike", timeout: int = 300, extra_args: Optional[str] = None) -> Dict[str, Any]`

**功能：** 使用 XSStrike 工具对 URL 进行反射型 XSS 检测和利用。

**参数：**
- `url` (str): 目标 URL
- `xsstrike_path` (str, 可选): XSStrike 可执行文件路径，默认 `"xsstrike"`
- `timeout` (int, 可选): 执行超时时间（秒），默认 300
- `extra_args` (Optional[str], 可选): 额外的 XSStrike 命令行参数

**返回值：**
```python
{
    "type": "xsstrike",
    "success": bool,               # 是否检测到 XSS
    "evidence": {},                # 当前不提取具体证据
    "raw_output": str,             # 命令输出（前 4000 字符）
    "cmd": str,                    # 实际执行的命令
}
```

**默认参数：**
- `--crawl`: 抓取并测试页面
- `--skip-dom`: 跳过 DOM XSS 检测
- `--blind`: 包含 blind XSS 检测

**成功判断：**
输出中包含 `Reflected`、`Vulnerable`、`Payload` 或 `Bypassed` 关键词（大小写不敏感）

**示例：**
```python
result = await run_xsstrike(
    url="http://example.com/search.php?q=test",
    extra_args="--encode"
)
if result["success"]:
    print("检测到 XSS 漏洞")
```

---

### `async run_commix(url: str, commix_path: str = "commix", timeout: int = 300, extra_args: Optional[str] = None) -> Dict[str, Any]`

**功能：** 使用 commix 工具检测命令注入漏洞。

**参数：**
- `url` (str): 目标 URL
- `commix_path` (str, 可选): commix 可执行文件路径，默认 `"commix"`
- `timeout` (int, 可选): 执行超时时间（秒），默认 300
- `extra_args` (Optional[str], 可选): 额外的 commix 命令行参数

**返回值：**
```python
{
    "type": "commix",
    "success": bool,               # 是否检测到命令注入
    "evidence": {},                # 当前不提取具体证据
    "raw_output": str,             # 命令输出（前 4000 字符）
    "cmd": str,                    # 实际执行的命令
}
```

**默认参数：**
- `--batch`: 非交互模式

**成功判断：**
输出中包含 `OS shell` 或 `command injection` 关键词（大小写不敏感）

**示例：**
```python
result = await run_commix(
    url="http://example.com/ping.php?ip=127.0.0.1",
    extra_args="--technique=classic"
)
if result["success"]:
    print("检测到命令注入漏洞")
```

---

### `async run_msfconsole_cmd(command: str, msfconsole_path: str = "msfconsole", timeout: int = 120) -> Dict[str, Any]`

**功能：** 使用 Metasploit Framework 的 msfconsole 执行指定命令。

**参数：**
- `command` (str): 要执行的 msfconsole 命令序列，多命令用分号分隔
  - 示例: `"version; exit"`, `"search cve-2024-xxxxx; exit"`
- `msfconsole_path` (str, 可选): msfconsole 可执行文件路径，默认 `"msfconsole"`
- `timeout` (int, 可选): 执行超时时间（秒），默认 120

**返回值：**
```python
{
    "type": "msfconsole",
    "success": bool,               # 命令是否执行成功
    "evidence": {},                # 当前不提取证据
    "raw_output": str,             # 命令输出（前 4000 字符）
    "cmd": str,                    # 实际执行的命令
}
```

**工作流程：**
1. 检查 msfconsole 可执行文件是否存在
2. 以非交互模式 (`-q`) 执行指定命令
3. 返回码为 0 或输出包含 "Framework" 时判定为成功

**执行参数：**
- `-q`: 静默模式（不显示 banner 等）
- `-x`: 指定要执行的命令

**示例：**
```python
result = await run_msfconsole_cmd(
    command="version; exit"
)
if result["success"]:
    print("Metasploit Framework 可用")

# 搜索特定漏洞模块
result = await run_msfconsole_cmd(
    command="search cve-2021-22911; exit",
    timeout=60
)
```

---

## 错误处理

所有异步函数都遵循以下错误处理原则：

1. **超时处理**：进程超时时自动杀死，返回 `success=False` 和超时提示
2. **工具不存在**：使用 `shutil.which()` 检查可执行文件，缺失时返回失败
3. **权限问题**：特定工具（如 BeEF）检查 root 权限，权限不足则跳过
4. **异常捕获**：所有异常被捕获并转换为结构化的失败响应
5. **输出截断**：大输出自动截断至 4000-6000 字符以防止内存溢出

---

## 集成建议

### 与 predict_scanner.py 集成

```python
from core.exploit_engine import run_sqlmap, run_xsstrike, run_commix

# 在漏洞扫描流程中调用
results = []

# SQL 注入检测
if "sql_injection" in detected_vulns:
    result = await run_sqlmap(url=target_url, param=param_name)
    results.append(result)

# XSS 检测
if "xss" in detected_vulns:
    result = await run_xsstrike(url=target_url)
    results.append(result)

# 命令注入检测
if "command_injection" in detected_vulns:
    result = await run_commix(url=target_url)
    results.append(result)
```

### 与 report_generator.py 集成

```python
# 在报告生成中包含利用证据
for result in exploit_results:
    if result["success"]:
        report.add_section(
            title=f"{result['type']} Exploitation",
            content=result["evidence"],
            raw_output=result["raw_output"]
        )
```

---

## 依赖安装

各工具的安装方式：

```bash
# sqlmap
pip install sqlmap
# 或从官方源下载：https://github.com/sqlmapproject/sqlmap

# XSStrike
pip install xsstrike

# commix
git clone https://github.com/commixproject/commix.git
cd commix && python commix.py

# BeEF XSS Framework
git clone https://github.com/beefproject/beef.git

# Metasploit Framework
# 参考官方文档：https://www.metasploit.com/
```

---

## 性能考虑

1. **并发执行**：各函数为 `async`，支持通过 `asyncio.gather()` 并发运行多个漏洞检测
2. **超时配置**：根据网络情况调整 timeout 参数，避免过长的等待
3. **输出限制**：输出自动截断，防止超大输出导致性能下降
4. **临时文件**：sqlmap 使用临时目录存放输出，自动清理

---
