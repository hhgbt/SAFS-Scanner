import asyncio
import json
import re
import shutil
import tempfile
import glob
import os
from typing import Dict, Any, Optional, Tuple


def _parse_sqlmap_output(text: str) -> Dict[str, Any]:
    evidence = {}
    # Try multiple patterns to be robust across versions/locales
    patterns = {
        "banner": [r"banner\s*:\s*(.+)", r"server\s*banner\s*:\s*(.+)"],
        "current_user": [r"current\s*user\s*:\s*([\w@.-]+)", r"user\s*:\s*([\w@.-]+)"],
        "current_db": [r"current\s*db\s*:\s*([\w@.-]+)", r"database\s*:\s*([\w@.-]+)"],
    }
    for key, pats in patterns.items():
        for pat in pats:
            m = re.search(pat, text, flags=re.IGNORECASE)
            if m:
                evidence[key] = m.group(1).strip()
                break
    return evidence


def _find_first_key(obj: Any, keys) -> Optional[Any]:
    if isinstance(obj, dict):
        for k in keys:
            if k in obj and obj[k]:
                return obj[k]
        for v in obj.values():
            found = _find_first_key(v, keys)
            if found:
                return found
    elif isinstance(obj, list):
        for v in obj:
            found = _find_first_key(v, keys)
            if found:
                return found
    return None


def _parse_sqlmap_json(obj: Any) -> Tuple[Dict[str, Any], Optional[str]]:
    evidence: Dict[str, Any] = {}
    payload_used: Optional[str] = None

    # 尝试从结构化 JSON 中提取常见字段
    banner = _find_first_key(obj, ["banner", "dbmsBanner", "serverBanner", "dbms"])
    current_user = _find_first_key(obj, ["current_user", "currentUser", "user"])
    current_db = _find_first_key(obj, ["current_db", "currentDb", "database", "db"])
    payload_used = _find_first_key(obj, ["payload", "vector"])

    if banner:
        evidence["banner"] = banner
    if current_user:
        evidence["current_user"] = current_user
    if current_db:
        evidence["current_db"] = current_db

    return evidence, payload_used


async def run_sqlmap(url: str, param: str, sqlmap_path: str = "sqlmap", timeout: int = 600, extra_args: Optional[str] = None) -> Dict[str, Any]:
    """
    Run sqlmap for a given URL and parameter. Returns a structured result.
    Uses --batch for non-interactive and fetches banner/current-user/current-db.
    优先使用 --json + 输出目录解析结构化结果；回退到正则解析。
    """

    async def _execute(with_json: bool, out_dir: str):
        # 当 param 为空或为 "ALL" 时，让 sqlmap 自动检测参数（省略 -p）
        if not param or str(param).upper() == "ALL":
            base_cmd = f"{sqlmap_path} -u '{url}' --batch --banner --current-user --current-db --level=3 --risk=2 --flush-session --output-dir='{out_dir}'"
        else:
            base_cmd = f"{sqlmap_path} -u '{url}' -p {param} --batch --banner --current-user --current-db --level=3 --risk=2 --flush-session --output-dir='{out_dir}'"
        if with_json:
            base_cmd += " --json"
        cmd_full = f"{base_cmd} {extra_args}" if extra_args else base_cmd
        proc = await asyncio.create_subprocess_shell(
            cmd_full,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
        except asyncio.TimeoutError:
            proc.kill()
            raise
        return proc.returncode, (stdout or b"").decode(errors="ignore"), (stderr or b"").decode(errors="ignore"), cmd_full

    try:
        with tempfile.TemporaryDirectory(prefix="sqlmap-json-") as out_dir:
            try:
                rc, out_text, err_text, cmd = await _execute(True, out_dir)
            except asyncio.TimeoutError:
                return {
                    "type": "sqlmap",
                    "success": False,
                    "evidence": {},
                    "raw_output": "[timeout] sqlmap execution exceeded timeout",
                    "cmd": f"{sqlmap_path} --json ...",
                }
            # 兼容不支持 --json 的版本
            if rc != 0 and "--json" in err_text.lower():
                try:
                    rc, out_text, err_text, cmd = await _execute(False, out_dir)
                except asyncio.TimeoutError:
                    return {
                        "type": "sqlmap",
                        "success": False,
                        "evidence": {},
                        "raw_output": "[timeout] sqlmap execution exceeded timeout",
                        "cmd": f"{sqlmap_path} ...",
                    }

            combined = (out_text + "\n" + err_text)[:4000]

            # 尝试解析 JSON 输出
            evidence: Dict[str, Any] = {}
            payload_used: Optional[str] = None
            json_blob = None
            try:
                json_files = glob.glob(os.path.join(out_dir, "**", "*.json"), recursive=True)
                for jf in json_files:
                    with open(jf, "r", encoding="utf-8", errors="ignore") as f:
                        json_blob = json.load(f)
                        if json_blob:
                            break
            except Exception:
                json_blob = None

            if json_blob:
                parsed_ev, payload_used = _parse_sqlmap_json(json_blob)
                evidence.update(parsed_ev)
                # 附带原始 JSON 片段，便于审计
                evidence["json"] = json_blob

            # 如果 JSON 为空或未覆盖，回退正则解析
            if not evidence:
                evidence.update(_parse_sqlmap_output(combined))

            # 若仍缺少证据，附加日志尾部兜底
            if not evidence:
                log_tail = ""
                try:
                    log_files = glob.glob(os.path.join(out_dir, "**", "*.log"), recursive=True)
                    txt_files = glob.glob(os.path.join(out_dir, "**", "output.txt"), recursive=True)
                    for lf in log_files + txt_files:
                        with open(lf, "r", encoding="utf-8", errors="ignore") as f:
                            lines = f.readlines()
                            if lines:
                                tail = lines[-10:]
                                log_tail = "".join(tail)
                                break
                except Exception:
                    log_tail = ""
                if log_tail:
                    combined = (combined + "\n[log tail]\n" + log_tail)[:6000]

            success = any(evidence.values())

            return {
                "type": "sqlmap",
                "success": success,
                "evidence": evidence,
                "payload": payload_used,
                "raw_output": combined,
                "cmd": cmd,
            }
    except Exception as e:
        return {
            "type": "sqlmap",
            "success": False,
            "evidence": {},
            "raw_output": f"[error] {e}",
            "cmd": sqlmap_path,
        }


async def run_beef_xss(beef_path: str = "beef-xss", timeout: int = 20) -> Dict[str, Any]:
    """
    Try to launch BeEF briefly to verify availability. Stops after timeout window.
    Note: Full hooking requires separate configuration and victim navigation.
    """
    resolved = shutil.which(beef_path) if beef_path else None
    if not resolved:
        return {"type": "beef-xss", "success": False, "evidence": {}, "raw_output": "beef-xss not found", "cmd": "beef-xss"}
    # 若无 root 权限则直接跳过，避免无意义的失败
    try:
        if hasattr(os, "geteuid") and os.geteuid() != 0:
            return {"type": "beef-xss", "success": False, "evidence": {}, "raw_output": "beef-xss requires root, skipped", "cmd": resolved}
    except Exception:
        pass
    try:
        proc = await asyncio.create_subprocess_exec(
            resolved,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        try:
            await asyncio.sleep(timeout)
            proc.kill()
        except Exception:
            pass
        stdout, stderr = await proc.communicate()
        combined = (((stdout or b"") + b"\n" + (stderr or b""))).decode(errors="ignore")[:4000]
        started = bool(re.search(r"BeEF", combined, re.IGNORECASE)) or proc.returncode in (None, 0)
        return {"type": "beef-xss", "success": started, "evidence": {}, "raw_output": combined, "cmd": resolved}
    except Exception as e:
        return {"type": "beef-xss", "success": False, "evidence": {}, "raw_output": f"[error] {e}", "cmd": resolved or "beef-xss"}


async def run_xsstrike(url: str, xsstrike_path: str = "xsstrike", timeout: int = 300, extra_args: Optional[str] = None) -> Dict[str, Any]:
    """
    Run XSStrike against a URL to validate/exploit reflected XSS. Evidence is basic parsing of findings.
    """
    base_cmd = f"{xsstrike_path} -u '{url}' --crawl --skip-dom --blind"
    cmd = f"{base_cmd} {extra_args}" if extra_args else base_cmd
    try:
        proc = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
        except asyncio.TimeoutError:
            proc.kill()
            return {"type": "xsstrike", "success": False, "evidence": {}, "raw_output": "[timeout]", "cmd": cmd}
        out_text = (stdout or b"").decode(errors="ignore")
        err_text = (stderr or b"").decode(errors="ignore")
        combined = (out_text + "\n" + err_text)[:4000]
        # naive evidence: look for common success strings
        success = bool(re.search(r"(Reflected|Vulnerable|Payload|Bypassed)", combined, re.IGNORECASE))
        return {"type": "xsstrike", "success": success, "evidence": {}, "raw_output": combined, "cmd": cmd}
    except Exception as e:
        return {"type": "xsstrike", "success": False, "evidence": {}, "raw_output": f"[error] {e}", "cmd": cmd}


async def run_commix(url: str, commix_path: str = "commix", timeout: int = 300, extra_args: Optional[str] = None) -> Dict[str, Any]:
    """
    Run commix against a URL for command injection verification.
    """
    base_cmd = f"{commix_path} -u '{url}' --batch"
    cmd = f"{base_cmd} {extra_args}" if extra_args else base_cmd
    try:
        proc = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
        except asyncio.TimeoutError:
            proc.kill()
            return {"type": "commix", "success": False, "evidence": {}, "raw_output": "[timeout]", "cmd": cmd}
        out_text = (stdout or b"").decode(errors="ignore")
        err_text = (stderr or b"").decode(errors="ignore")
        combined = (out_text + "\n" + err_text)[:4000]
        success = bool(re.search(r"(OS shell|command injection)", combined, re.IGNORECASE))
        return {"type": "commix", "success": success, "evidence": {}, "raw_output": combined, "cmd": cmd}
    except Exception as e:
        return {"type": "commix", "success": False, "evidence": {}, "raw_output": f"[error] {e}", "cmd": cmd}


async def run_msfconsole_cmd(command: str, msfconsole_path: str = "msfconsole", timeout: int = 120) -> Dict[str, Any]:
    """
    Run msfconsole with a short -x command sequence (non-interactive). Example: 'version; exit'.
    """
    resolved = shutil.which(msfconsole_path) if msfconsole_path else None
    if not resolved:
        return {"type": "msfconsole", "success": False, "evidence": {}, "raw_output": "msfconsole not found", "cmd": "msfconsole"}
    cmd = f"{resolved} -q -x \"{command}\""
    try:
        proc = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
        except asyncio.TimeoutError:
            proc.kill()
            return {"type": "msfconsole", "success": False, "evidence": {}, "raw_output": "[timeout]", "cmd": cmd}
        combined = (((stdout or b"") + b"\n" + (stderr or b""))).decode(errors="ignore")[:4000]
        ok = proc.returncode == 0 or "Framework" in combined
        return {"type": "msfconsole", "success": ok, "evidence": {}, "raw_output": combined, "cmd": cmd}
    except Exception as e:
        return {"type": "msfconsole", "success": False, "evidence": {}, "raw_output": f"[error] {e}", "cmd": cmd}

